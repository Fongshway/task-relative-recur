#!/usr/bin/env python

from __future__ import print_function
from builtins import str

import datetime
import json
import sys
import subprocess
import uuid
import os
import tempfile
import time

TIME_FORMAT = '%Y%m%dT%H%M%SZ'
UDA_DUE = 'relativeRecurDue'
UDA_WAIT = 'relativeRecurWait'

env = os.environ.copy()
env['TZ'] = 'UTC0'

# Hand back duration format parsing to task warrior
def calc(statement):
	calc = subprocess.Popen(['task', 'rc.verbose=nothing', 'rc.date.iso=yes', 'calc', statement], stdout=subprocess.PIPE, env=env)
	out, err = calc.communicate()
	# Workaround for TW-1254 (https://bug.tasktools.org/browse/TW-1254)
	return out.decode("utf-8").rstrip().replace('-', '').replace(':', '') + 'Z'

# Parse the modified task
original = json.loads(sys.stdin.readline())
modified = sys.stdin.readline()
# Return the unmodified modified task, so it is actually changed
print(modified)
modified = json.loads(modified)


def should_trigger_hook(orig, mod):
	"""Has a task with UDA been marked as completed?"""
	# Does the task have a relativeRecur UDA?
	has_uda = False
	for uda in {UDA_DUE, UDA_WAIT}:
		if uda in orig:
			has_uda = True
			break

	# Has the task been marked as completed?
	marked_completed = orig['status'] != 'completed' and mod['status'] == 'completed'
	return has_uda and marked_completed


if should_trigger_hook(original, modified):
	del original['modified']
	if 'start' in original:
		del original['start']
	if UDA_DUE in original:
		original['due'] = calc(modified['end'] + '+' + original[UDA_DUE])
	if UDA_WAIT in original:
		original['wait'] = calc(modified['end'] + '+' + original[UDA_WAIT])
		original['status'] = 'waiting'
	else:
		original['status'] = 'pending'
	print('Created follow-up task')
	original['entry'] = modified['end']
	original['uuid'] = str(uuid.uuid4())

	# Wait for taskwarrior to finish, so we can safely `task import` the new task
	sys.stdout.flush()
	task_pid = os.getppid()
	if (0 < os.fork()):
		sys.exit(0)
	else:
		# Taskwarrior also waits for stdout to close
		try:
			os.close(sys.stdout.fileno())
		except OSError:
			pass # Thrown because of closing stdout. Don't worry, that's fine.

		# Wait for taskwarrior to finish
		while (os.path.exists("/proc/%s" % str(task_pid))):
			time.sleep(0.25)

		# Import the follow-up task
		with tempfile.NamedTemporaryFile(mode="wt") as new_task:
			new_task.write(json.dumps(original));
			new_task.flush();
			add = subprocess.Popen(['task', 'rc.verbose=nothing', 'import', new_task.name], env=env)
			add.communicate();
